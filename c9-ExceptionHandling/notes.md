# Exception Handling

This chapter discusses exception handling. An **exception** is an **error that occurs at run time**. Using Java’s exception handling subsystem you can, in a structured and controlled manner,handle run-time errors.

## The Exception Hierarchy

In Java, all exceptions are **represented by classes**. All exception classes are **derived** from a class called **Throwable**.There are **two direct subclasses** of Throwable: **Exception** and **Error**.

## Exception Handling Fundamentals

Java exception handling is managed via five keywords: **try, catch, throw, throws, and finally**.

Program statements that you want to monitor for exceptions are contained within a try block. If an exception occurs within the try block, it is thrown. Your code can catch this exception using catch and handle it in some rational manner.

To manually throw an exception, use the keyword **throw**. In some cases, an exception that is thrown out of a method must be specified as such by a **throws** clause. Any code that absolutely must be executed upon exiting from a **try** block is put in a **finally** block.

Exceptions are generated in three different ways:

1. The **JVM can generate an exception** in response to some internal error which is **beyond your control**

2. **Standard exceptions**, such as those corresponding to divide-by-zero or array index out-of-bounds, are generated by **errors in program code**. **You** need to **handle these exceptions**.

3. **You can manually generate an exception** by using the **throw** statement. No matter how an exception is generated, it is handled in the same way.

## Using try and catch

At the core of exception handling are **try** and **catch**. These keywords work together;**you can’t have a catch without a try**. Here is the general form of the try/catch exception handling blocks:

```Java
try {
    // block of code to monitor for errors
}
catch (ExcepType1 exOb) {
    // handler for ExcepType1
}
catch (ExcepType2 exOb) {
    // handler for ExcepType2
}
.
.
.
```

Here, **ExcepType** is the type of exception that has occurred. When an exception is thrown, it is caught by its corresponding catch statement, which then processes the exception. As the general form shows, **there can be more than one catch statement associated with a try**. The **type** of the **exception** determines which catch statement is **executed**.

```Java
//Demonstrate exception handling
class ExcDemo1 {
    public static void main(String[] args) {
        int[] nums = new int[4];
        try {
            System.out.println("Before exception is generated.");
            // Generate an index out-of-bounds exception
            nums[7] = 10;
            System.out.println("This won't be displayed");
        } catch (ArrayIndexOutOfBoundsException exc) {
            // catch the exception
            System.out.println("Index out-of-bounds!");
        }
        System.out.println("After catch statement.");
    }
}
```

Output:\
Before exception is generated.\
Index out-of-bounds!\
After catch statement.

## The Consequences of an Uncaught Exception

If your **program does not catch an exception**, then it will be caught by the JVM. The trouble is that the **JVM’s default exception handler terminates execution** and displays a stack trace and error message.

The **type** of the **exception** must **match** the type specified in a **catch statement**. If it doesn’t, the exception won’t be caught.

```Java
// This won't work
class ExcTypeMismatch {
    public static void main(String[] args) {
        int[] nums = new int[4];
        try {
            System.out.println("Before exception is generated");
            // generate an index out of bounds exception
            nums[7] = 10;
            System.out.println("This won't be displayed");
        } /*
           * Can't catch an array boundary error with an
           * ArithmeticException
           */
        catch (ArithmeticException exc) {
            // catch the exception
            System.out.println("Index out of bounds!");
        }
    }
}
```

Output:\
Before exception is generated\
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException:Index 7 out of bounds for length 4\
at ExcTypeMismatch.main(ExcTypeMismatch.java:8)

## Using Multiple catch Statements

You can associate **more than one catch** statement with a try. In fact, it is common to do so. However, **each catch must catch a different type of exception**. For example, the program shown here catches both array boundary and divide-by-zero errors:

```Java
// Use multiple catch statements
class ExcDemo4 {
    public static void main(String[] args) {
        // Here, numer is longer than denom
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        for (int i = 0; i < numer.length; i++) {
            try {
                System.out.println(numer[i] + " / " +
                        denom[i] + " is " +
                        numer[i] / denom[i]);
            } catch (ArithmeticException exc) {
                System.out.println("Can't divide by Zero");
            } catch (ArrayIndexOutOfBoundsException exc) {
                System.out.println("No matching element found");
            }
        }
    }
}
```

Output:\
4 / 2 is 2\
Can't divide by Zero\
16 / 4 is 4\
32 / 4 is 8\
Can't divide by Zero\
128 / 8 is 16\
No matching element found\
No matching element found

## Catching Subclass Exceptions

A **catch** clause for a superclass will also match any of its subclasses. For example, since the superclass of all exceptions is **Throwable**, to catch all possible exceptions, catch **Throwable**. If you want to catch exceptions of both a superclass type and a subclass type, put the **subclass first in the catch sequence**. For example, consider the following program:

```java
// Subclasses must precede superclasses in catch statements.
class ExcDemo5 {
    public static void main(String[] args) {
        // Here, numer is longer than denom.
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        for (int i = 0; i < numer.length; i++) {
            try {
                System.out.println(numer[i] + " / " +
                        denom[i] + " is " +
                        numer[i] / denom[i]);
            } catch (ArrayIndexOutOfBoundsException exc) {
                // catch the exception
                System.out.println("No matching element found");
            } catch (Throwable exc) {
                System.out.println("Some exception occurred.");
            }
        }
    }
}
```

Output:\
4 / 2 is 2\
Some exception occurred.\
16 / 4 is 4\
32 / 4 is 8\
Some exception occurred.\
128 / 8 is 16\
No matching element found\
No matching element found

In this case, **catch(Throwable) catches all exceptions except for ArrayIndexOutOfBounds- Exception**. The issue of catching subclass exceptions becomes more important when you create exceptions of your own.

## Try Blocks Can Be Nested

One **try** block can be nested within another. An exception generated within the inner **try** block that is not caught by a **catch** associated with that **try** is propagated to the **outer try** block. For example, here the **ArrayIndexOutOfBoundsException** is not caught by the inner **catch**, but by the outer **catch**:

```Java
//Use a nested try block
class NestTrys {
    public static void main(String[] args) {
        // Here, numer is longer than denom.
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        try {// outer try
            for (int i = 0; i < numer.length; i++) {
                try {// nested try

                    System.out.println(numer[i] + " / " +
                            denom[i] + " is " +
                            numer[i] / denom[i]);
                } catch (ArithmeticException exc) {
                    // catch the exception
                    System.out.println("Can't divide by Zero!");
                }
            }
        } catch (ArrayIndexOutOfBoundsException exc) {
            // catch the exception
            System.out.println("No matching element found.");
            System.out.println("Fatal error - program terminated.");
        }
    }
}
```

Output:\
4 / 2 is 2\
Can't divide by Zero!\
16 / 4 is 4\
32 / 4 is 8\
Can't divide by Zero!\
128 / 8 is 16\
No matching element found.\
Fatal error - program terminated.

In this example, an exception that can be handled by the inner try—in this case, a divide-by-zero error—allows the program to continue. However, an array boundary error is caught by the outer try, which causes the program to terminate.

Often nested try blocks are used to allow different categories of errors to be handled in different ways. Some types of errors are catastrophic and cannot be fixed. Some are minor and can be handled immediately. You might use an outer try block to catch the most severe errors, allowing inner try blocks to handle less
serious ones.
